Trace Demo (13) - MCP Traffic sichtbar machen
=============================================

Ziel: Minimal-Setup, um MCP HTTP/SSE Calls mitzuschneiden (Server-Seite) und im Client ueber `trace.logs` einzusehen. Kein LLM notwendig.

Was passiert?
- Server loggt jede HTTP-Anfrage (inkl. MCP JSON-RPC) in ein In-Memory-Trace-Log.
- Resource `trace/logs` gibt das Log aus.
- Tools `trace.ping` und `trace.echo` loesen Verkehr aus.

Start:
- Server: `dotnet run` in `13/server` (Standard: http://localhost:5700, SSE `/sse`).
- Client: `dotnet run` in `13/client` (nutzt MCP_SERVER_URL, falls gesetzt).

Client-Menue:
1) `trace.ping` (Tool) -> ping/pong
2) `trace.echo` (Tool) -> Text eingeben, Echo erhalten
3) `trace.logs` lesen (Resource) -> zeigt HTTP-Requests/Antworten
4) Tools listen

Was man sieht:
- GET /sse Handshake und POSTs der JSON-RPC Calls im Trace.
- Body pro Request/Response bis 800 Zeichen (Sicherheit: gekuerzt).
- HTTP-Status/Content-Type je Eintrag.
- Beispiel-Sequenz (Sampling):
  - In der CLI `trace.ping` ausfuehren.
  - Danach `trace.logs` lesen: du siehst erst den POST mit JSON-RPC-Body (methods: tools/call), danach die 200-Response.
  - Optional `trace.echo` mit Text wie "hello trace" senden; im Log siehst du Request+Response sowie SSE-Verbindung (GET /sse).

Hinweise:
- Middleware + HttpLogging loggen nur auf Serverseite; fuer Client-seitiges Logging einfach erneut `trace.logs` lesen.
- Grenzen: Body-Preview 800 Zeichen, 64 Eintraege im Rolling-Buffer.
- Bei Bedarf Port via ASPNETCORE_URLS oder MCP_SERVER_URL umstellen.
