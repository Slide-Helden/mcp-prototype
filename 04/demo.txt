Demo 04: Live Communication Trace
==================================
Aufbauend auf Demo 01-03 | +Transparenz | +Protokoll-Details

WAS WIR ZEIGEN: Die MCP-Kommunikation zwischen Client, Server und LLM
wird in Echtzeit sichtbar. Man sieht jeden Request live.

NEU GEGENUEBER DEMO 01-03:
- Echtes SDK-Logging zeigt MCP-Protokoll-Details
- JSON-RPC Payloads werden sichtbar
- Konfigurierbare Log-Level (Debug, Trace)

USE-CASE: Koch-Assistent mit Rezeptkatalog

VERFUEGBARE MCP-BAUSTEINE:
- Tools: docs.search, docs.random, trace.stats, trace.clear
- Resources: docs/catalog, docs/document/{id}, trace/logs
- Rezepte: Gnocchi Pesto Genovese, Tomatensuppe, Carbonara, Lasagne, u.v.m.

VORBEREITUNG
------------
Terminal 1: cd 04/server && dotnet run
Terminal 2: cd 04/client && dotnet run

Server laeuft auf http://localhost:5000/sse

LOG-LEVEL ANPASSEN (Program.cs Zeile 19)
----------------------------------------
var logLevel = LogLevel.Debug;    // Standard: Wichtige Infos
var logLevel = LogLevel.Trace;    // Deep-Dive: Zeigt JSON-RPC Payloads!

TIPP FUER DEMO: Mit LogLevel.Trace sieht man die kompletten
JSON-RPC Requests/Responses - ideal um das Protokoll zu erklaeren.

SCHRITT-FUER-SCHRITT
--------------------

1. EINSTIEG - Rezepte erkunden
   Eingabe: Welche Rezepte hast du?

   -> SDK-Logging zeigt:
      - MCP resources/list Request
      - JSON-RPC Payload (bei Trace-Level)
      - Tool-Aufrufe des LLM

   -> Erklaere: Jede Log-Zeile = ein Schritt in der Kommunikation

2. EINZELNES REZEPT
   Eingabe: Wie mache ich die Gnocchi?

   -> Logging zeigt Tool-Call fuer docs/document/recipe_gnocchi...
   -> Erklaere: LLM findet ID im Katalog, liest dann das Rezept

3. VERGLEICH (MULTI-TOOL)
   Eingabe: Vergleiche Gnocchi und Tomatensuppe - welches ist schneller?

   -> Logging zeigt MEHRERE Tool-Calls nacheinander
   -> Erklaere: LLM orchestriert mehrere Abrufe selbststaendig

4. HALLUZINATIONS-TEST
   Eingabe: Wie mache ich Sushi?

   -> Logging zeigt: LLM sucht, findet nichts
   -> Erwartet: Ehrliche Antwort "Kein Sushi-Rezept vorhanden"
   -> Erklaere: Grounding verhindert Halluzination

5. SERVER-TRACE ANZEIGEN
   Eingabe: :trace:server

   -> Zeigt die Server-Perspektive: HTTP-Requests, JSON-RPC
   -> Erklaere: Gleiche Kommunikation, andere Sichtweise

TRACE-BEFEHLE
-------------
:trace:server - Server-Trace abrufen
:trace:stats  - Trace-Statistiken vom Server

PROTOKOLL-DETAILS (bei LogLevel.Trace sichtbar)
-----------------------------------------------
Typischer JSON-RPC Request:
  {"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"docs.search"}}

Protokoll-Elemente:
- jsonrpc: Protokoll-Version (immer "2.0")
- id: Request-ID fuer Zuordnung
- method: MCP-Methode (tools/call, resources/read, etc.)
- params: Parameter des Aufrufs
- result: Antwort (bei Erfolg)

KERNAUSSAGE
-----------
"Jetzt sehen wir, was 'unter der Haube' passiert:
 JSON-RPC Aufrufe, HTTP Requests, Tool-Calls.
 MCP ist JSON-RPC 2.0 ueber HTTP - ein offener Standard."

UEBERLEITUNG ZU DEMO 05
-----------------------
"Bisher brauchten wir immer ein LLM.
 Aber MCP funktioniert auch ohne KI -
 als reiner Standard-Connector."
